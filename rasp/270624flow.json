[{"id":"993456db.6e41d8","type":"tab","label":"Flow 3","disabled":false,"info":""},{"id":"435d4ab3.5afc44","type":"inject","z":"993456db.6e41d8","name":"B","props":[{"p":"payload"},{"p":"topic","vt":"str"}],"repeat":"","crontab":"","once":false,"onceDelay":0.1,"topic":"teamB","payload":"{\"action\": \"B\"}","payloadType":"json","x":190,"y":220,"wires":[["24f584ef.1f069c","5c8c51a1.c2016"]]},{"id":"108919a2.d39446","type":"inject","z":"993456db.6e41d8","name":"Undo","props":[{"p":"payload"},{"p":"topic","vt":"str"}],"repeat":"","crontab":"","once":false,"onceDelay":0.1,"topic":"undo","payload":"{\"action\": \"Undo\"}","payloadType":"json","x":190,"y":260,"wires":[["24f584ef.1f069c","5c8c51a1.c2016"]]},{"id":"24f584ef.1f069c","type":"debug","z":"993456db.6e41d8","name":"","active":false,"tosidebar":true,"console":false,"tostatus":false,"complete":"false","statusVal":"","statusType":"auto","x":410,"y":140,"wires":[]},{"id":"8e1b9975.402078","type":"inject","z":"993456db.6e41d8","name":"Reset","props":[{"p":"payload"},{"p":"topic","vt":"str"}],"repeat":"","crontab":"","once":false,"onceDelay":0.1,"topic":"reset","payload":"{\"action\": \"Reset\"}","payloadType":"json","x":190,"y":140,"wires":[["24f584ef.1f069c","5c8c51a1.c2016"]]},{"id":"90c5e874.c67b88","type":"inject","z":"993456db.6e41d8","name":"A","props":[{"p":"payload"},{"p":"topic","vt":"str"}],"repeat":"","crontab":"","once":false,"onceDelay":0.1,"topic":"teamA","payload":"{\"action\": \"A\"}","payloadType":"json","x":190,"y":180,"wires":[["24f584ef.1f069c","5c8c51a1.c2016"]]},{"id":"95836f17.249f4","type":"debug","z":"993456db.6e41d8","name":"","active":false,"tosidebar":true,"console":false,"tostatus":false,"complete":"false","statusVal":"","statusType":"auto","x":850,"y":160,"wires":[]},{"id":"fd5eded.af67f2","type":"debug","z":"993456db.6e41d8","name":"","active":true,"tosidebar":true,"console":true,"tostatus":false,"complete":"payload","targetType":"msg","statusVal":"","statusType":"auto","x":640,"y":160,"wires":[]},{"id":"5c8c51a1.c2016","type":"function","z":"993456db.6e41d8","name":"Actions Logic","func":"function generateUniqueID() {\n    return Date.now().toString(36) + Math.random().toString(36).substring(2);\n}\n//////////////////////////////////////////////////////////////////////\nfunction updateScore(teamIndex) {\n    console.log(`------------------updating`);\n //asigno valores globales a variables locales para facilitar la manipulación dentro de los condicionales, cuando tengo que cambiar valores utilizo la notación completa de la variable global\n    let cG = quadra.match.score.currentGame;    //currentGame\n    let cSI = quadra.match.score.currentSet;    //currenSetIndex\n    let cS = quadra.match.score.sets[cSI];      //currenSet\n    let pS = JSON.parse(JSON.stringify(quadra.match.score)); // Hacer una copia profunda antes de modificar//previousScore\n   \n    console.log( \"----->cs: \",cS, \" cSI:\" , cSI, \" pScore:\", pS);\n    \n    //Registro en los historiales\n    quadra.match.actionHistory.push({action:teamIndex === 0 ? \"pointA\" : \"pointB\"});\n    quadra.match.scoreHistory.push(pS);\n    // Incrementar el punto para el equipo especificado y al final de la función actualizo valores globales\n    cG[teamIndex] += 1;\n\n    // Verificar si hay un ganador del Game\n    if ((cG[0] >= 4 || cG[1] >= 4) && Math.abs(cG[0] - cG[1]) >= 2) {\n        //sumo 1 al set correspondiente y \n         cS[teamIndex]+=1;\n\n\n        // Verificar si hay un ganador del set\n        if (cS[teamIndex] >= 6 && Math.abs(cS[0] - cS[1]) >= 2) {\n            //if (cSI < cS.length - 1) {\n            if (cSI < cS.length) {\n                cSI +=1;\n                cS = [0 , 0];\n                    console.log(`incremento de indice`);\n\n            } else {\n                  // me muevo al otro set o si ya estaba en el tercer set GANADOR DEL PARTIDO en otra función\n              console.log(`+++++++++++++++++++FindePartido+++++++++++++++++++++`);\n            }\n        }\n        // Reiniciar el juego actual\n        cG[0] = 0;\n        cG[1] = 0;\n    }\n    //    quadra.match.scoreHistory.push({ prevScore: pS});\n\n\n    // Actualizo valores globales\n    quadra.match.score.currentGame = cG;\n    quadra.match.score.currentSet = cSI;\n    quadra.match.score.sets[cSI] = cS ; \n}\n//////////////////////////////////////////////////////////////////////////////////////////\n// Obtener el objeto 'quadra' del contexto de flujo\nlet quadra = flow.get('quadra') || {\n    match: {\n        matchID: generateUniqueID(),  // Generar un ID único para el partido\n        gameTime: 0,  // Tiempo transcurrido del partido en segundos o formato deseado\n        score: {\n            sets: [[0, 0], [0, 0], [0, 0]],  // Array para almacenar los juegos ganados en cada set\n            currentSet: 0,  // Índice del set actual en el array de sets\n            currentGame: [0, 0],  // Puntuación del juego actual\n        },\n        actionHistory: [],  // Historial de todas las acciones realizadas\n        scoreHistory: []  // Historial de los cambios de puntuación para poder deshacer cambios\n    }    \n};\n// Evaluar la acción proveniente del nodo inject\nswitch (msg.payload.action) {\n    case \"A\":\n        // Sumar punto al Equipo A\n        updateScore(0);\n        break;\n    case \"B\":\n        // Sumar punto al Equipo B\n        updateScore(1);\n        break;\n    case \"Undo\":\n    // Deshacer la última acción\n    let aH = quadra.match.actionHistory;\n    let sH = quadra.match.scoreHistory;\n    if (aH.length > 0 && sH.length > 0){\n        quadra.match.actionHistory.pop();   //Delete last action\n        let previousState = quadra.match.scoreHistory.pop();    //Delete last score\n            console.log(\"Undo - Restoring to previous state:\", previousState);\n        // Restaurar el estado completo del partido\n        quadra.match.score = JSON.parse(JSON.stringify(previousState));\n    }\n           // quadra.match.scoreHistory.pop();    //Delete last score\n\n    /*if (court.matchs.actionHistory.length > 0 && court.matchs.gameHistory.length > 0) {\n        court.matchs.actionHistory.pop();  // Eliminar la última acción registrada\n        court.matchs.gameHistory.pop();  // Eliminar el último estado de juego registrado\n\n        // Restaurar el estado del juego al estado previo al último, si existe\n        if (court.matchs.gameHistory.length > 0) {\n            court.matchs.currentGame = [...court.matchs.gameHistory[court.matchs.gameHistory.length - 1]];\n        } else {\n            court.matchs.currentGame = [0, 0];  // Restablecer a cero si no hay más historial\n        }\n\n        // Restaurar el estado del set si es necesario\n        if (court.matchs.setHistory.length > 0) {\n            court.matchs.sets = [...court.matchs.setHistory.pop()];\n        }\n    }*/\n        break;\n    case \"Reset\":\n        // Reiniciar el partido\n        quadra.match.score.sets = [[0, 0], [0, 0], [0, 0]];\n        quadra.match.score.currentSet = 0;\n        quadra.match.score.currentGame = [0, 0];\n        quadra.match.actionHistory = [];\n        quadra.match.scoreHistory = [];\n        quadra.match.gameTime= 0; // Tiempo transcurrido del partido en segundos o formato deseado\n        break;\n    default:\n        // Por si se recibe una acción no esperada\n        node.warn(\"Acción no reconocida: \" + msg.payload.action);\n        break;\n}\n\n// Guardar el estado actualizado\nflow.set('quadra', quadra);\n\n// Pasar el estado actualizado al siguiente nodo (si es necesario)\nreturn {payload: quadra};\n","outputs":1,"noerr":0,"initialize":"","finalize":"","x":410,"y":240,"wires":[["fd5eded.af67f2"]]},{"id":"65aa1597.0a17dc","type":"function","z":"993456db.6e41d8","name":"set 0","func":"let quadra = {\n    match: {\n        matchID: \"\",  // Generar un ID único para el partido\n        gameTime: 0,  // Tiempo transcurrido del partido en segundos o formato deseado\n        score: {\n            sets: [[0, 0], [0, 0], [0, 0]],  // Array para almacenar los juegos ganados en cada set\n            currentSet: 0,  // Índice del set actual en el array de sets\n            currentGame: [0, 0],  // Puntuación del juego actual\n        },\n        actionHistory: [],  // Historial de todas las acciones realizadas\n        scoreHistory: []  // Historial de los cambios de puntuación para poder deshacer cambios\n    }    \n};\nflow.set('quadra', quadra);\nreturn {payload: quadra};\n","outputs":1,"noerr":0,"initialize":"","finalize":"","x":250,"y":40,"wires":[[]]},{"id":"786b88da.6662e8","type":"function","z":"993456db.6e41d8","name":"Actions Logic","func":"// Obtener el objeto 'court' del contexto de flujo\nlet court = flow.get('court') || {matchs: {currentGame: {pointsA: 0, pointsB: 0}, history: [], sets: []}};\n\n// Evaluar la acción proveniente del nodo inject\nswitch (msg.payload.action) {\n    case \"A\":\n        // Sumar punto al Equipo A\n        court.matchs.currentGame.pointsA += 1;\n        court.matchs.history.push({action: \"pointA\"});\n        break;\n    case \"B\":\n        // Sumar punto al Equipo B\n        court.matchs.currentGame.pointsB += 1;\n        court.matchs.history.push({action: \"pointB\"});\n        break;\n    case \"Undo\":\n        // Deshacer la última acción\n        let lastAction = court.matchs.history.pop();\n        if (lastAction) {\n            switch (lastAction.action) {\n                case \"pointA\":\n                    court.matchs.currentGame.pointsA -= 1;\n                    break;\n                case \"pointB\":\n                    court.matchs.currentGame.pointsB -= 1;\n                    break;\n                // Agregar más casos si hay otras acciones que deshacer\n            }\n        }\n        break;\n    case \"Reset\":\n        // Reiniciar el partido\n        court.matchs.sets = [];\n        court.matchs.currentGame = {pointsA: 0, pointsB: 0};\n        court.matchs.history = [];\n        break;\n    default:\n        // Por si se recibe una acción no esperada\n        node.warn(\"Acción no reconocida: \" + msg.payload.action);\n        break;\n}\n\n// Guardar el estado actualizado\nflow.set('court', court);\n\n// Pasar el estado actualizado al siguiente nodo (si es necesario)\nreturn {payload: court};\n","outputs":1,"noerr":0,"initialize":"","finalize":"","x":1110,"y":700,"wires":[[]]},{"id":"8a36eeb.c7b941","type":"function","z":"993456db.6e41d8","name":"Actions Logic","func":"// Obtener el objeto 'court' del contexto de flujo\nlet court = flow.get('court') || {matchs: {currentGame: [0, 0], gameHistory: [], actionHistory: [], sets: []}};\n\n// Evaluar la acción proveniente del nodo inject\nswitch (msg.payload.action) {\n    case \"A\":\n        // Sumar punto al Equipo A\n        court.matchs.currentGame[0] += 1;\n        court.matchs.actionHistory.push(\"pointA\");\n        court.matchs.gameHistory.push([...court.matchs.currentGame]);\n        break;\n    case \"B\":\n        // Sumar punto al Equipo B\n        court.matchs.currentGame[1] += 1;\n        court.matchs.actionHistory.push(\"pointB\");\n        court.matchs.gameHistory.push([...court.matchs.currentGame]);\n        break;\n    case \"Undo\":\n        // Deshacer la última acción\n        let lastAction = court.matchs.actionHistory.pop();\n        if (lastAction) {\n            switch (lastAction) {\n                case \"pointA\":\n                    court.matchs.currentGame[0] -= 1;\n                    break;\n                case \"pointB\":\n                    court.matchs.currentGame[1] -= 1;\n                    break;\n                // Agregar más casos si hay otras acciones que deshacer\n            }\n            court.matchs.gameHistory.pop();  // Remover el último estado guardado\n        }\n        break;\n    case \"Reset\":\n        // Reiniciar el partido\n        court.matchs.sets = [];\n        court.matchs.currentGame = [0, 0];\n        court.matchs.actionHistory = [];\n        court.matchs.gameHistory = [];\n        break;\n    default:\n        // Por si se recibe una acción no esperada\n        node.warn(\"Acción no reconocida: \" + msg.payload.action);\n        break;\n}\n\n// Guardar el estado actualizado\nflow.set('court', court);\n\n// Pasar el estado actualizado al siguiente nodo (si es necesario)\nreturn {payload: court};\n","outputs":1,"noerr":0,"initialize":"","finalize":"","x":1110,"y":660,"wires":[[]]},{"id":"80016193.488db","type":"function","z":"993456db.6e41d8","name":"Actions Logic stable","func":"function updateScore(teamIndex) {\n    court.matchs.currentGame[teamIndex] += 1;\n    court.matchs.actionHistory.push(teamIndex === 0 ? \"pointA\" : \"pointB\");\n    court.matchs.gameHistory.push([...court.matchs.currentGame]);\n}\n\n\n// Obtener el objeto 'court' del contexto de flujo\nlet court = flow.get('court') || {\n    matchs: {\n        currentGame: [0, 0],\n        gameHistory: [],\n        actionHistory: [],\n        sets: [[0, 0], [0, 0], [0, 0]],  // Tres sets, cada uno con juegos para el Equipo A y B\n        setHistory: []\n    }\n};\n// Evaluar la acción proveniente del nodo inject\nswitch (msg.payload.action) {\n    case \"A\":\n        // Sumar punto al Equipo A\n        updateScore(0);\n        break;\n    case \"B\":\n        // Sumar punto al Equipo B\n        updateScore(1);\n        break;\ncase \"Undo\":\n    // Deshacer la última acción\n    if (court.matchs.actionHistory.length > 0 && court.matchs.gameHistory.length > 0) {\n        court.matchs.actionHistory.pop();  // Eliminar la última acción registrada\n        court.matchs.gameHistory.pop();  // Eliminar el último estado de juego registrado\n        \n        // Restaurar el estado del juego al estado previo al último, si existe\n        if (court.matchs.gameHistory.length > 0) {\n            court.matchs.currentGame = [...court.matchs.gameHistory[court.matchs.gameHistory.length - 1]];\n        } else {\n            court.matchs.currentGame = [0, 0];  // Restablecer a cero si no hay más historial\n        }\n    }\n    break;\n    case \"Reset\":\n        // Reiniciar el partido\n        court.matchs.sets = [];\n        court.matchs.currentGame = [0, 0];\n        court.matchs.actionHistory = [];\n        court.matchs.gameHistory = [];\n        break;\n    default:\n        // Por si se recibe una acción no esperada\n        node.warn(\"Acción no reconocida: \" + msg.payload.action);\n        break;\n}\n\n// Guardar el estado actualizado\nflow.set('court', court);\n\n// Pasar el estado actualizado al siguiente nodo (si es necesario)\nreturn {payload: court};\n","outputs":1,"noerr":0,"initialize":"","finalize":"","x":180,"y":560,"wires":[[]]},{"id":"2c353197.950c9e","type":"function","z":"993456db.6e41d8","name":"Actions Logic","func":"function updateScore(teamIndex) {\n    court.matchs.currentGame[teamIndex] += 1;\n    court.matchs.actionHistory.push(teamIndex === 0 ? \"pointA\" : \"pointB\");\n    court.matchs.gameHistory.push([...court.matchs.currentGame]);\n    checkGameWin();\n}\n\nfunction checkGameWin() {\n    let [pointsA, pointsB] = court.matchs.currentGame;\n    // Verificar si algún equipo ha ganado el juego\n    if ((pointsA >= 4 || pointsB >= 4) && Math.abs(pointsA - pointsB) >= 2) {\n        let gameWinner = pointsA > pointsB ? 0 : 1;\n\n        // Identificar el set actual más apropiadamente\n        let currentSet = court.matchs.sets.find(set => set[0] < 6 || set[1] < 6);\n        if (!currentSet) {\n            // Si todos los sets están llenos, iniciar un nuevo set si es necesario\n            currentSet = [0, 0];\n            court.matchs.sets.push(currentSet);\n        }\n\n        // Guardar estado actual del set antes de cambiarlo\n        court.matchs.setHistory.push([...court.matchs.sets]);\n\n        // Incrementar el contador de juegos ganados por el ganador del juego\n        currentSet[gameWinner] += 1;\n\n        // Verificar si el set ha sido ganado\n        if (currentSet[gameWinner] >= 6 && Math.abs(currentSet[0] - currentSet[1]) >= 2) {\n            // Preparar para un nuevo set, si no es el final del partido\n            court.matchs.sets.push([0, 0]);\n        }\n\n        // Resetear el estado del juego actual\n        court.matchs.currentGame = [0, 0];\n    }\n}\n\n// Obtener el objeto 'court' del contexto de flujo\nlet court = flow.get('court') || {\n    matchs: {\n        currentGame: [0, 0],\n        gameHistory: [],\n        actionHistory: [],\n        sets: [[0, 0], [0, 0], [0, 0]],  // Tres sets, cada uno con juegos para el Equipo A y B\n        setHistory: []\n    }\n};\n// Evaluar la acción proveniente del nodo inject\nswitch (msg.payload.action) {\n    case \"A\":\n        // Sumar punto al Equipo A\n        updateScore(0);\n        break;\n    case \"B\":\n        // Sumar punto al Equipo B\n        updateScore(1);\n        break;\n/*case \"Undo\":\n    // Deshacer la última acción\n    if (court.matchs.actionHistory.length > 0 && court.matchs.gameHistory.length > 0) {\n        court.matchs.actionHistory.pop();  // Eliminar la última acción registrada\n        court.matchs.gameHistory.pop();  // Eliminar el último estado de juego registrado\n        \n        // Restaurar el estado del juego al estado previo al último, si existe\n        if (court.matchs.gameHistory.length > 0) {\n            court.matchs.currentGame = [...court.matchs.gameHistory[court.matchs.gameHistory.length - 1]];\n        } else {\n            court.matchs.currentGame = [0, 0];  // Restablecer a cero si no hay más historial\n        }\n    }\n    break;\n    */\n    case \"Undo\":\n    // Deshacer la última acción\n    if (court.matchs.actionHistory.length > 0 && court.matchs.gameHistory.length > 0) {\n        court.matchs.actionHistory.pop();  // Eliminar la última acción registrada\n        court.matchs.gameHistory.pop();  // Eliminar el último estado de juego registrado\n\n        // Restaurar el estado del juego al estado previo al último, si existe\n        if (court.matchs.gameHistory.length > 0) {\n            court.matchs.currentGame = [...court.matchs.gameHistory[court.matchs.gameHistory.length - 1]];\n        } else {\n            court.matchs.currentGame = [0, 0];  // Restablecer a cero si no hay más historial\n        }\n\n        // Restaurar el estado del set si es necesario\n        if (court.matchs.setHistory.length > 0) {\n            court.matchs.sets = [...court.matchs.setHistory.pop()];\n        }\n    }\n    break;\n    case \"Reset\":\n        // Reiniciar el partido\n        court.matchs.sets = [];\n        court.matchs.currentGame = [0, 0];\n        court.matchs.actionHistory = [];\n        court.matchs.gameHistory = [];\n        break;\n    default:\n        // Por si se recibe una acción no esperada\n        node.warn(\"Acción no reconocida: \" + msg.payload.action);\n        break;\n}\n\n// Guardar el estado actualizado\nflow.set('court', court);\n\n// Pasar el estado actualizado al siguiente nodo (si es necesario)\nreturn {payload: court};\n","outputs":1,"noerr":0,"initialize":"","finalize":"","x":1070,"y":600,"wires":[[]]},{"id":"de7a6741.87be28","type":"function","z":"993456db.6e41d8","name":"Actions Logic","func":"function updateScore(teamIndex) {\n   // court.matchs.score.currentGame[teamIndex] += 1;\n    //court.matchs.actionHistory.push(teamIndex === 0 ? \"pointA\" : \"pointB\");\n    //court.matchs.gameHistory.push([...court.matchs.currentGame]);\n    //checkGame();\n}\n\n// Obtener el objeto 'court' del contexto de flujo\nlet court = flow.get('court') || {\n    matchs: {\n        //currentGame: [0, 0],\n        gameHistory: [],\n        actionHistory: [],\n        //sets: [[0, 0], [0, 0], [0, 0]],  // Tres sets, cada uno con juegos para el Equipo A y B\n        setHistory: [],\n        score: {currentGame: [0, 0],sets: [[0, 0], [0, 0], [0, 0]]}\n    }\n};\n// Evaluar la acción proveniente del nodo inject\nswitch (msg.payload.action) {\n    case \"A\":\n        // Sumar punto al Equipo A\n        updateScore(0);\n        break;\n    case \"B\":\n        // Sumar punto al Equipo B\n        updateScore(1);\n        break;\n/*case \"Undo\":\n    // Deshacer la última acción\n    if (court.matchs.actionHistory.length > 0 && court.matchs.gameHistory.length > 0) {\n        court.matchs.actionHistory.pop();  // Eliminar la última acción registrada\n        court.matchs.gameHistory.pop();  // Eliminar el último estado de juego registrado\n        \n        // Restaurar el estado del juego al estado previo al último, si existe\n        if (court.matchs.gameHistory.length > 0) {\n            court.matchs.currentGame = [...court.matchs.gameHistory[court.matchs.gameHistory.length - 1]];\n        } else {\n            court.matchs.currentGame = [0, 0];  // Restablecer a cero si no hay más historial\n        }\n    }\n    break;\n    */\n    case \"Undo\":\n    // Deshacer la última acción\n    if (court.matchs.actionHistory.length > 0 && court.matchs.gameHistory.length > 0) {\n        court.matchs.actionHistory.pop();  // Eliminar la última acción registrada\n        court.matchs.gameHistory.pop();  // Eliminar el último estado de juego registrado\n\n        // Restaurar el estado del juego al estado previo al último, si existe\n        if (court.matchs.gameHistory.length > 0) {\n            court.matchs.currentGame = [...court.matchs.gameHistory[court.matchs.gameHistory.length - 1]];\n        } else {\n            court.matchs.currentGame = [0, 0];  // Restablecer a cero si no hay más historial\n        }\n\n        // Restaurar el estado del set si es necesario\n        if (court.matchs.setHistory.length > 0) {\n            court.matchs.sets = [...court.matchs.setHistory.pop()];\n        }\n    }\n    break;\n    case \"Reset\":\n        // Reiniciar el partido\n        court.matchs.sets = [];\n        court.matchs.currentGame = [0, 0];\n        court.matchs.actionHistory = [];\n        court.matchs.gameHistory = [];\n        break;\n    default:\n        // Por si se recibe una acción no esperada\n        node.warn(\"Acción no reconocida: \" + msg.payload.action);\n        break;\n}\n\n// Guardar el estado actualizado\nflow.set('court', court);\n\n// Pasar el estado actualizado al siguiente nodo (si es necesario)\nreturn {payload: court};\n","outputs":1,"noerr":0,"initialize":"","finalize":"","x":1130,"y":560,"wires":[[]]},{"id":"3d5410de.4b743","type":"function","z":"993456db.6e41d8","name":"Actions Logic","func":"function generateUniqueID() {\n    return Date.now().toString(36) + Math.random().toString(36).substring(2);\n}\nfunction finalizeMatch(winningTeamIndex) {\n    // Aquí se puede manejar la lógica para finalizar el partido\n    let match = quadra.match;\n    match.status = \"completed\"; // Marcar el partido como completado\n    match.winner = winningTeamIndex === 0 ? \"Team A\" : \"Team B\"; // Determinar el ganador basado en el índice\n\n    // Otras acciones como notificaciones o registros pueden ser añadidas aquí\n    console.log(`Match completed. Winner: ${match.winner}`);\n}\nfunction updateScore(teamIndex) {\n    //asigno valores globales a variables locales para facilitar la manipulación dentro de los if, cuando tengo que cambiar valores utilizo la notación completa de la variable global\n    let cG = quadra.match.score.currentGame;    //currentGame\n    let cSI = quadra.match.score.currentSet;    //currenSetIndex\n    let cS = quadra.match.score.sets[cSI];      //currenSet\n\n    // Incrementar el punto para el equipo especificado y al final de la función actualizo valores globales\n    cG[teamIndex] += 1;\n\n    // Verificar si hay un ganador del Game\n     if ((cG[0] >= 4 || cG[1] >= 4) && Math.abs(cG[0] - cG[1]) >= 2) {\n        // Reiniciar el juego actual.\n        cG[0] = 0;\n        cG[1] = 0;\n\n        // Incrementar el contador de juegos ganados en el set actual.\n        cS[teamIndex] += 1;\n\n        // Verificar si hay un ganador del set.\n        if (cS[teamIndex] >= 6 && Math.abs(cS[0] - cS[1]) >= 2) {\n            if (cSI < quadra.match.score.sets.length - 1) {\n                // Avanzar al siguiente set si no es el último.\n                quadra.match.score.currentSet += 1;\n            } else {\n                finalizeMatch(teamIndex); // Llamar a finalizar el partido si no hay más sets\n            }\n        }\n    }\n\n    // Actualizo valores globales.\n    quadra.match.score.currentGame = cG;\n    quadra.match.score.sets[cSI] = cS;\n\n    // Registro en los historiales.\n    quadra.match.actionHistory.push({action: teamIndex === 0 ? \"pointA\" : \"pointB\", gameScore: [...cG]});\n    quadra.match.scoreHistory.push({set: cSI, game: [...cG], setScore: [...cS]});\n}\n\n// Obtener el objeto 'quadra' del contexto de flujo\nlet quadra = flow.get('quadra') || {\n    match: {\n        matchID: generateUniqueID(),  // Generar un ID único para el partido\n        status:\"pending\",\n        score: {\n            sets: [[0, 0], [0, 0], [0, 0]],  // Array para almacenar los juegos ganados en cada set\n            currentSet: 0,  // Índice del set actual en el array de sets\n            currentGame: [0, 0],  // Puntuación del juego actual\n        },\n        actionHistory: [],  // Historial de todas las acciones realizadas\n        scoreHistory: [],  // Historial de los cambios de puntuación para poder deshacer cambios\n        gameTime: 0  // Tiempo transcurrido del partido en segundos o formato deseado\n    }    \n};\n// Evaluar la acción proveniente del nodo inject\nswitch (msg.payload.action) {\n    case \"A\":\n        // Sumar punto al Equipo A\n        updateScore(0);\n        break;\n    case \"B\":\n        // Sumar punto al Equipo B\n        updateScore(1);\n        break;\n    case \"Undo\":\n    // Deshacer la última acción\n    /*if (court.matchs.actionHistory.length > 0 && court.matchs.gameHistory.length > 0) {\n        court.matchs.actionHistory.pop();  // Eliminar la última acción registrada\n        court.matchs.gameHistory.pop();  // Eliminar el último estado de juego registrado\n\n        // Restaurar el estado del juego al estado previo al último, si existe\n        if (court.matchs.gameHistory.length > 0) {\n            court.matchs.currentGame = [...court.matchs.gameHistory[court.matchs.gameHistory.length - 1]];\n        } else {\n            court.matchs.currentGame = [0, 0];  // Restablecer a cero si no hay más historial\n        }\n\n        // Restaurar el estado del set si es necesario\n        if (court.matchs.setHistory.length > 0) {\n            court.matchs.sets = [...court.matchs.setHistory.pop()];\n        }\n    }*/\n        break;\n    case \"Reset\":\n        // Reiniciar el partido\n        quadra.match.score.sets = [[0, 0], [0, 0], [0, 0]];\n        quadra.match.score.currentSet = 0;\n        quadra.match.score.currentGame = [0, 0];\n        quadra.match.actionHistory = [];\n        quadra.match.scoreHistory = [];\n        quadra.match.gameTime= 0; // Tiempo transcurrido del partido en segundos o formato deseado\n        break;\n    default:\n        // Por si se recibe una acción no esperada\n        node.warn(\"Acción no reconocida: \" + msg.payload.action);\n        break;\n}\n\n// Guardar el estado actualizado\nflow.set('quadra', quadra);\n\n// Pasar el estado actualizado al siguiente nodo (si es necesario)\nreturn {payload: quadra};\n","outputs":1,"noerr":0,"initialize":"","finalize":"","x":1150,"y":520,"wires":[[]]},{"id":"1039a8e6.633857","type":"inject","z":"993456db.6e41d8","name":"","props":[{"p":"payload"},{"p":"topic","vt":"str"}],"repeat":"","crontab":"","once":false,"onceDelay":0.1,"topic":"","payload":"","payloadType":"date","x":100,"y":40,"wires":[["65aa1597.0a17dc"]]},{"id":"b4150420.dd8f28","type":"function","z":"993456db.6e41d8","name":"Actions Logic stable without UNDO","func":"function generateUniqueID() {\n    return Date.now().toString(36) + Math.random().toString(36).substring(2);\n}\nfunction updateScore(teamIndex) {\n    console.log(`------------------updating`);\n //asigno valores globales a variables locales para facilitar la manipulación dentro de los if, cuando tengo que cambiar valores utilizo la notación completa de la variable global\n    let cG = quadra.match.score.currentGame;    //currentGame\n    let cSI = quadra.match.score.currentSet;    //currenSetIndex\n    let cS = quadra.match.score.sets[cSI];      //currenSet\n    console.log( \"cs: \",cS, \" cSI:\" , cSI);\n\n    // Incrementar el punto para el equipo especificado y al final de la función actualizo valores globales\n    cG[teamIndex] += 1;\n\n    // Verificar si hay un ganador del Game\n    if ((cG[0] >= 4 || cG[1] >= 4) && Math.abs(cG[0] - cG[1]) >= 2) {\n        //sumo 1 al set correspondiente y \n         cS[teamIndex]+=1;\n\n\n        // Verificar si hay un ganador del set\n        if (cS[teamIndex] >= 6 && Math.abs(cS[0] - cS[1]) >= 2) {\n            //if (cSI < cS.length - 1) {\n            if (cSI < cS.length) {\n                cSI +=1;\n                cS = [0 , 0];\n                    console.log(`incremento de indice`);\n\n            } else {\n                  // me muevo al otro set o si ya estaba en el tercer set GANADOR DEL PARTIDO en otra función\n                  console.log(`+++++++++++++++++++FindePartido`);\n\n            }\n        }\n        // Reiniciar el juego actual\n        cG[0] = 0;\n        cG[1] = 0;\n    }\n    \n    // Actualizo valores globales\n    quadra.match.score.currentGame = cG;\n    quadra.match.score.currentSet = cSI;\n    quadra.match.score.sets[cSI] = cS ; //revisar\n\n    \n    //Registro en los historiales\n    //quadra.match.actionHistory.push({action:teamIndex === 0 ? \"pointA\" : \"pointB\"});\n    //quadra.match.scoreHistory.push({ previusScore: [quadra.match.score]});\n    //quadra.match.scoreHistory.push({ previusScore: {cS , cG}});\n}\n\n// Obtener el objeto 'quadra' del contexto de flujo\nlet quadra = flow.get('quadra') || {\n    match: {\n        matchID: generateUniqueID(),  // Generar un ID único para el partido\n        gameTime: 0,  // Tiempo transcurrido del partido en segundos o formato deseado\n        score: {\n            sets: [[0, 0], [0, 0], [0, 0]],  // Array para almacenar los juegos ganados en cada set\n            currentSet: 0,  // Índice del set actual en el array de sets\n            currentGame: [0, 0],  // Puntuación del juego actual\n        },\n        actionHistory: [],  // Historial de todas las acciones realizadas\n        scoreHistory: []  // Historial de los cambios de puntuación para poder deshacer cambios\n    }    \n};\n// Evaluar la acción proveniente del nodo inject\nswitch (msg.payload.action) {\n    case \"A\":\n        // Sumar punto al Equipo A\n        updateScore(0);\n        break;\n    case \"B\":\n        // Sumar punto al Equipo B\n        updateScore(1);\n        break;\n    case \"Undo\":\n    // Deshacer la última acción\n    /*if (court.matchs.actionHistory.length > 0 && court.matchs.gameHistory.length > 0) {\n        court.matchs.actionHistory.pop();  // Eliminar la última acción registrada\n        court.matchs.gameHistory.pop();  // Eliminar el último estado de juego registrado\n\n        // Restaurar el estado del juego al estado previo al último, si existe\n        if (court.matchs.gameHistory.length > 0) {\n            court.matchs.currentGame = [...court.matchs.gameHistory[court.matchs.gameHistory.length - 1]];\n        } else {\n            court.matchs.currentGame = [0, 0];  // Restablecer a cero si no hay más historial\n        }\n\n        // Restaurar el estado del set si es necesario\n        if (court.matchs.setHistory.length > 0) {\n            court.matchs.sets = [...court.matchs.setHistory.pop()];\n        }\n    }*/\n        break;\n    case \"Reset\":\n        // Reiniciar el partido\n        quadra.match.score.sets = [[0, 0], [0, 0], [0, 0]];\n        quadra.match.score.currentSet = 0;\n        quadra.match.score.currentGame = [0, 0];\n        quadra.match.actionHistory = [];\n        quadra.match.scoreHistory = [];\n        quadra.match.gameTime= 0; // Tiempo transcurrido del partido en segundos o formato deseado\n        break;\n    default:\n        // Por si se recibe una acción no esperada\n        node.warn(\"Acción no reconocida: \" + msg.payload.action);\n        break;\n}\n\n// Guardar el estado actualizado\nflow.set('quadra', quadra);\n\n// Pasar el estado actualizado al siguiente nodo (si es necesario)\nreturn {payload: quadra};\n","outputs":1,"noerr":0,"initialize":"","finalize":"","x":220,"y":520,"wires":[[]]},{"id":"1a3b33de.75e58c","type":"function","z":"993456db.6e41d8","name":"Actions Logic Stable with Undo","func":"function generateUniqueID() {\n    return Date.now().toString(36) + Math.random().toString(36).substring(2);\n}\n//////////////////////////////////////////////////////////////////////\nfunction updateScore(teamIndex) {\n    console.log(`------------------updating`);\n //asigno valores globales a variables locales para facilitar la manipulación dentro de los condicionales, cuando tengo que cambiar valores utilizo la notación completa de la variable global\n    let cG = quadra.match.score.currentGame;    //currentGame\n    let cSI = quadra.match.score.currentSet;    //currenSetIndex\n    let cS = quadra.match.score.sets[cSI];      //currenSet\n    let pS = JSON.parse(JSON.stringify(quadra.match.score)); // Hacer una copia profunda antes de modificar//previousScore\n   \n    console.log( \"----->cs: \",cS, \" cSI:\" , cSI, \" pScore:\", pS);\n    \n    //Registro en los historiales\n    quadra.match.actionHistory.push({action:teamIndex === 0 ? \"pointA\" : \"pointB\"});\n    quadra.match.scoreHistory.push(pS);\n    // Incrementar el punto para el equipo especificado y al final de la función actualizo valores globales\n    cG[teamIndex] += 1;\n\n    // Verificar si hay un ganador del Game\n    if ((cG[0] >= 4 || cG[1] >= 4) && Math.abs(cG[0] - cG[1]) >= 2) {\n        //sumo 1 al set correspondiente y \n         cS[teamIndex]+=1;\n\n\n        // Verificar si hay un ganador del set\n        if (cS[teamIndex] >= 6 && Math.abs(cS[0] - cS[1]) >= 2) {\n            //if (cSI < cS.length - 1) {\n            if (cSI < cS.length) {\n                cSI +=1;\n                cS = [0 , 0];\n                    console.log(`incremento de indice`);\n\n            } else {\n                  // me muevo al otro set o si ya estaba en el tercer set GANADOR DEL PARTIDO en otra función\n              console.log(`+++++++++++++++++++FindePartido+++++++++++++++++++++`);\n            }\n        }\n        // Reiniciar el juego actual\n        cG[0] = 0;\n        cG[1] = 0;\n    }\n    //    quadra.match.scoreHistory.push({ prevScore: pS});\n\n\n    // Actualizo valores globales\n    quadra.match.score.currentGame = cG;\n    quadra.match.score.currentSet = cSI;\n    quadra.match.score.sets[cSI] = cS ; \n}\n//////////////////////////////////////////////////////////////////////////////////////////\n// Obtener el objeto 'quadra' del contexto de flujo\nlet quadra = flow.get('quadra') || {\n    match: {\n        matchID: generateUniqueID(),  // Generar un ID único para el partido\n        gameTime: 0,  // Tiempo transcurrido del partido en segundos o formato deseado\n        score: {\n            sets: [[0, 0], [0, 0], [0, 0]],  // Array para almacenar los juegos ganados en cada set\n            currentSet: 0,  // Índice del set actual en el array de sets\n            currentGame: [0, 0],  // Puntuación del juego actual\n        },\n        actionHistory: [],  // Historial de todas las acciones realizadas\n        scoreHistory: []  // Historial de los cambios de puntuación para poder deshacer cambios\n    }    \n};\n// Evaluar la acción proveniente del nodo inject\nswitch (msg.payload.action) {\n    case \"A\":\n        // Sumar punto al Equipo A\n        updateScore(0);\n        break;\n    case \"B\":\n        // Sumar punto al Equipo B\n        updateScore(1);\n        break;\n    case \"Undo\":\n    // Deshacer la última acción\n    let aH = quadra.match.actionHistory;\n    let sH = quadra.match.scoreHistory;\n    if (aH.length > 0 && sH.length > 0){\n        quadra.match.actionHistory.pop();   //Delete last action\n        let previousState = quadra.match.scoreHistory.pop();    //Delete last score\n            console.log(\"Undo - Restoring to previous state:\", previousState);\n        // Restaurar el estado completo del partido\n        quadra.match.score = JSON.parse(JSON.stringify(previousState));\n    }\n           // quadra.match.scoreHistory.pop();    //Delete last score\n\n    /*if (court.matchs.actionHistory.length > 0 && court.matchs.gameHistory.length > 0) {\n        court.matchs.actionHistory.pop();  // Eliminar la última acción registrada\n        court.matchs.gameHistory.pop();  // Eliminar el último estado de juego registrado\n\n        // Restaurar el estado del juego al estado previo al último, si existe\n        if (court.matchs.gameHistory.length > 0) {\n            court.matchs.currentGame = [...court.matchs.gameHistory[court.matchs.gameHistory.length - 1]];\n        } else {\n            court.matchs.currentGame = [0, 0];  // Restablecer a cero si no hay más historial\n        }\n\n        // Restaurar el estado del set si es necesario\n        if (court.matchs.setHistory.length > 0) {\n            court.matchs.sets = [...court.matchs.setHistory.pop()];\n        }\n    }*/\n        break;\n    case \"Reset\":\n        // Reiniciar el partido\n        quadra.match.score.sets = [[0, 0], [0, 0], [0, 0]];\n        quadra.match.score.currentSet = 0;\n        quadra.match.score.currentGame = [0, 0];\n        quadra.match.actionHistory = [];\n        quadra.match.scoreHistory = [];\n        quadra.match.gameTime= 0; // Tiempo transcurrido del partido en segundos o formato deseado\n        break;\n    default:\n        // Por si se recibe una acción no esperada\n        node.warn(\"Acción no reconocida: \" + msg.payload.action);\n        break;\n}\n\n// Guardar el estado actualizado\nflow.set('quadra', quadra);\n\n// Pasar el estado actualizado al siguiente nodo (si es necesario)\nreturn {payload: quadra};\n","outputs":1,"noerr":0,"initialize":"","finalize":"","x":210,"y":480,"wires":[[]]}]
